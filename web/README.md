# CORS 에러 - 정의, 특징, 해결 방법

웹 브라우저에서 발생하는 보안 관련 오류 중 하나로, 다른 출처(origin)로부터 리소스를 로드하려는 시도가 실패할 때 발생한다.

웹 브라우저는 보안 상의 이유로 동일 출처 정책(Same-Origin Policy)을 따르는데, 이는 웹 페이지가 한 출처에서 로드된 리소스만 접근할 수 있다는 원칙이다. 

출처란 웹 페이지의 도메인, 포트, 프로토콜을 의미하며, 다른 출처에 있는 리소스에 접근하려면 해당 출처에서 CORS를 허용한다.

- 특징 

1. 오류 메시지: 보통 웹 브라우저의 개발자 도구 콘솔에서 확인할 수 있으며, 오류 메시지에는 <code>Access to XMLHttpRequest at 'URL' from origin 'origin' has been blocked by CORS policy</code>와 같이 출처 관련 정보가 포함한다.

2. Same-Origin Policy: 기본적으로 브라우저는 동일 출처 정책을 적용하며, 다른 출처에서 리소스에 접근하려면 해당 출처에서 CORS를 허용한다.

3. 보안: CORS는 웹 보안을 강화하기 위한 기술로, 잘못된 설정 또는 공격을 방지하기 위해 도입된다.

- CORS 에러 해결 방법:

1. 서버 설정: 서버 측에서 CORS를 허용하도록 설정해야 한다. 이를 위해서는 서버 응답 헤더에 CORS 관련 헤더를 추가해야 한다. 주요 헤더는 다음과 같습니다.

<code>Access-Control-Allow-Origin</code>: 허용할 출처를 지정한다. <code>*</code>는 모든 출처를 허용하는 것을 의미
<code>Access-Control-Allow-Methods</code>: 허용할 HTTP 메서드를 지정
<code>Access-Control-Allow-Headers</code>: 허용할 요청 헤더를 지정한다.
<code>Access-Control-Allow-Credentials</code>: 자격 증명 허용 여부를 지정한다.(예: 쿠키 전송 허용 여부).

2. 프록시 서버 사용: 클라이언트와 서버 사이에 프록시 서버를 두어 CORS 에러를 우회할 수 있다. 클라이언트는 프록시 서버에 요청을 보내고, 프록시 서버는 해당 요청을 서버로 전달하고 서버 응답을 클라이언트에게 전달한다. 이를 통해 서버와 클라이언트 간의 출처가 동일한 것처럼 동작할 수 있다.

3. JSONP 사용: <code>JSONP(JSON with Padding)</code>는 CORS 에러를 피하기 위한 대체 방법 중 하나로, 서버에서 <code>JSONP</code>를 지원하는 경우에 사용할 수 있다. 그러나 보안상의 이유로 사용을 권장하지 않는다.

### cors가 왜 등장했는지에 대해 설명해주세요.

보안 상의 이유로 등장했다. 출처가 다른 두 개의 어플리케이션이 마음대로 소통할 수 있는 환경은 꽤 위험한 환경이다. 웹에서 돌아가는 클라이언트 어플리케이션은 사용자의 공격에 너무나도 취약하기 떄문에 이런 상황 속에서 다른 출처의 어플리케이션이 서로 통신하는 것에 대해 아무런 제약도 존재하지 않는다면, 악의를 가진 사용자가 소스 코드를 쓱 구경한 후 <code>CSRF(Cross-Site Request Forgery)</code>나 XSS(Cross-Site Scripting)와 같은 방법을 사용한다면 어플리케이션에서 코드가 실행된 것처럼 꾸며서 사용자의 정보를 탈취하기가 너무나도 쉬워진다. 

여기서 <code>CSRF</code>란 웹 보안 공격 중 하나로, 공격자가 사용자의 웹 브라우저를 통해 사용자의 의지와 동의 없이 특정 웹 애플리케이션에 요청을 보내는 공격
<code>XSS(Cross Site Scripting)</code>는 공격자가 웹 페이지에 악성 스크립트 코드를 삽입하여 해당 스크립트 코드를 실행하도록 만드는 공격

# 쿠키, 세션, 로컬 스토리지의 장단점 
|  | LocalStorage | SessionStorage | Cookie |
| --- | --- | --- | --- |
| 데이터 유지 | 저장한 데이터를 지우지 않는 이상 영구적 보관이 가능 | 세선 종료 시 클라이언트에 대한 정보 삭제 | 만료 기간이 있음 |
| 최대 용량 | 5mb | 5mb | 4kb  |
| 탭 간에 공유 여부 | 다른 탭에서 값 공유 가능 | 탭마다의 고유한 값이므로 다른 탭에서 공유 안됨 | 도메인에 바인딩되므로 탭 간에 공유가 된다.  |
| 특징 | HTTP 요청에서 데이터를 주고받지 않고 LocalStorage를 이용하면 클라이언트와 서버간의 전체 트래픽과 낭비되는 대역폭의 양을 줄일 수 있음 | 탭/윈도우가 닫히면 스토리 초기화 | 모든 요청에 쿠키 정보가 포함되므로 서버 부담이 증가, 민감 정보 노출 가능성 |
| 사용 | 자동 로그인 | 일회성 로그인, 입력 폼 저장, 비로그인 장바구니 | ‘다시 보지 않음’ 팝업창, 로그인 자동 완성 |


# 비동기 함수에 대해서 설명해주세요.
비동기 함수(Asynchronous function)는 함수의 실행 결과가 즉시 반환되지 않고, 특정 조건이 충족될 때까지 기다리는 함수다. 비동기 함수는 일반적으로 <code>콜백 함수</code>나 <code>Promise</code> 객체를 반환한다.
<code>콜백 함수</code>는 비동기 작업이 완료되었을 때 호출되는 함수이며,
<code>Promise</code> 객체는 비동기 작업이 성공적으로 완료되었는지 혹은 실패했는지 나타내는 객체다.

비동기 함수는 애플리케이션의 성능을 향상시키고, 사용자 인터페이스의 반응성을 유지하는 데 유용하다. 그러나 비동기 함수를 사용할 때는 콜백 지옥과 같은 문제를 피하기 위해 적절한 에러 처리와 코드 구성이 필요하다. <code>여러 개의 비동기 함수가 실행되면, 이벤트 루프는 비동기 함수 호출을 처리하고, 비동기 함수가 완료되었을 때 콜백 함수를 호출한다.</code> 이벤트 루프는 실행 대기 중인 비동기 함수가 있으면 해당 함수를 호출하고, 실행이 완료될 때까지 다음 비동기 함수를 호출한다. 따라서, 여러 개의 비동기 함수가 실행될 때 이들 함수는 동시에 실행되며, 이벤트 루프에 의해 비동기 함수의 실행 순서가 제어된다.

### 그렇다면 비동기 함수는 왜 사용할까요?
- 응답 시간 개선: 비동기 함수를 사용하면 여러 작업을 동시에 처리할 수 있으므로 시스템 응답 시간을 개선할 수 있다. 특히 네트워크 호출, 파일 I/O 등의 작업에서 높은 효율을 얻을 수 있다.

- 블로킹 방지: 동기 함수는 한 작업이 끝나야 다음 작업을 진행할 수 있지만, 비동기 함수는 여러 작업을 동시에 처리하므로 다른 작업을 블로킹하지 않습니다. 이것은 대화 시스템에서 여러 요청을 동시에 처리하려는 경우에 유용한다.

- 자원 활용 최적화: 비동기 함수를 사용하면 CPU 및 기타 자원을 더 효율적으로 활용할 수 있다. 대기 시간이 긴 작업을 수행하는 동안 다른 작업을 수행할 수 있으므로 시스템의 성능이 향상됩니다.

# 브라우저의 렌더링 원리를 설명해주세요.

브라우저 렌더링은 HTML, CSS, Javascript 등의 웹 페이지 자원을 브라우저가 화면에 그리는 과정을 말한다. 브라우저 렌더링 원리와 순서는 크게 다음과 같은 단계로 구성됩니다.

1. 불러오기 (Loading)
    HTTP 모듈 또는 파일 시스템으로 전달 받은 리소스 스트림을 읽는 과정으로 로더가 이 역할을 맡고 있다. 로더는 단순히 읽는 것이 아니라, 이미 데이터를 읽었는지도 확인하고, 팝업창을 열지 말지, 또는 파일 다운로드 받을지를 결정한다.
    
2. 다운받은 HTML, CSS를 Object Model로 만든다.
    - HTML → DOM
        HTML파일은 HTML파서에 의해 파싱되어 DOM트리로 변환된다.
    - CSS → CSSOM (<link>, <style>을 통하여 생성)
        CSS파일은 CSS파서에 의해 파싱되어 CSSOM트리로 변환된다.
        
3. DOM과 CSSOM을 합쳐 Render tree를 만든다.
   
5. Layout
    렌더트리를 토대로 그려질 노드와 그 스타일값과 치수까지 계산한다.
    
6. Paint
    이 정보들을 페인팅 단계로 전달해서 렌더트리의 각 노드를 화면 상의 실제 픽셀로 변환한다.

다시 정리하자면 

1. DOM을 생성한다. 브라우저는 HTML 문서를 파싱하여 DOM 트리를 생성한다. 이때 HTML 태그를 노드로 변환하고, 노드 간의 계층 관계를 형성한다.
2. 브라우저는 CSS 파일을 파싱하여 CSSOM을 생성한다. 이때, CSS 속성을 노드로 변환하고, 노드간의 계층 관계를 형성한다.
3. DOM 트리와 CSSOM을 결합하여 렌더 트리를 생성한다. 이때 실제 화면에 표시될 요소만을 선택하여 렌더 트리를 형성한다. 
4. 이제, 브라우저는 렌더 트리를 이용하여 각 요소의 크기와 위치를 계산하는 과정인 레이아웃을 거쳐 화면에 요소를 그리는 페인팅 과정을 거치게 됩니다. 이때, 요소의 배경, 테두리, 글자 등을 그리게 됩니다. 

# Reflow와 Repaint에 대해 설명해주세요.

브라우저에서 Render Tree는 문서의 시각적 측면에서 올바른 순서대로 내용을 그리도록 하기 위한 목적을 갖고 있다. 따라서 DOM과 Render Tree는 항상 일치하지는 않는다. 예를 들어, display: none이나 head 같은 건 트리에서 제외시킨다. 그리고 브라우저는 layout 산출 후 painting 처리를 한다.
여기서 layout 계산을 다시 하는 것을 reflow, painting을 다시하는 것을 repainting이라고 하고 이것은 대개 필연적이다. 이것은 리소스를 소모하고 성능 저하를 유발할 수 있기 때문에 원인을 알고 최소화하는 것이 중요하다.

# Reflow와 Repaint가 실행되는 시점
1. Reflow
- DOM 엘리먼트 추가, 제거 또는 변경
- CSS 스타일 추가, 제거 또는 변경
- CSS 스타일을 직접 변경하거나, 클래스를 추가함으로써 레이아웃이 변경될 수 있다. 
- 엘리먼트의 길이를 변경하면, DOM 트리에 있는 다른 노드에 영향을 줄 수 있다.
- CSS3 애니메이션과 트랜지션. 애니메이션의 모든 프레임에서 리플로우가 발생한다.
- offsetWidth 와 offsetHeight 의 사용. offsetWidth 와 offsetHeight 속성을 읽으면, 초기 리플로우가 트리거되어 수치가 계산됩니다.
- 유저 행동. 유저 인터랙션으로 발생하는 hover 효과, 필드에 텍스트 입력, 창 크기 조정, 글꼴 - 크기 변경, 스타일시트 또는 글꼴 전환등을 활성화하여 리플로우를 트리거할 수 있다.

2. Repaint
- 가시성이 변경되는 순간 (opacity, background-color, visibility, outline)
- Reflow 가 실행된 순간 뒤에 실행됩니다.

# 크로스 브라우징이란?

최대한 많은 종류의 웹 브라우저에서 정상적으로 작동하는 웹페이지를 만드는 방법론 중 하나다. 지금처럼 브라우저 하나가 시장을 독점하지 않고 다양한 브라우저가 시장을 나눠가지고 있을때 개발자는 그 다양한 브라우저에 호환되는 웹페이지를 개발해야한다. 따라서 W3C에 채택된 웹표준 기술을 기본으로 제작해야한다.

동일하게 보이는 것이 아니라, 동등한 수준의 정보, 기능 제공이 우선이기 때문에 제작자가 의도한 내용을 이상 없이 동작하게 하는 게 크로스 브라우징의 의미입니다.

# 웹 개발 시 고려해야 할 보안 공격에 대해서 설명해주세요.

1. SQL injection
서버에서 실행되는 SQL을 악위적으로 이용하는 공격, SQL 구문을 삽입하여 데이터 탈취, 삭제 등을 할 수 있다.

2. Cross-Site Scription (XSS)
웹 페이지에 악성 자바스크립트를 삽입하는 공격
보통 Cookie 혹은 LocalStorage을 탈취한다. -> 불특정 다수의 사용자 토큰을 손쉽게 탈취 

3. CSRF Attack(Cross-Site Request Forgery)
공격자가 서비스 사용자를 이용하여 요청을 보내는 공격 
예를 들어 네이버 로그인과 똑같은 화면을 제공하는 피싱 사이트를 이용하여 아이디와 비밀번호를 탈취하는 것이다. 
만약 CSRF에 대한 방어가 제대로 안되어 있다면 성공/실패 Response가 내려올 것이고 이를 통해 해커는 성공한 계정 정보를 판단하여 탈취할 수 있게 된다.

4. File Upload Attack
공격 스크립트가 담긴 파일을 서버로 업로드하는 공격이다.

5. Command Injection
쉘을 실행시키는 로직을 이용한 공격으로 시스템 권한이 탈취되는 것과 마찬가지로 치명적이다.
각 언어마다 쉘 명령을 실행할 수 있는 API가 존재하는데 이러한 API를 해커가 호출할 수 있게 방어가 안되어 있다면 치명적인 결과를 불러올 수 있다.

6. Javascript Injection
브라우저 console을 통해 Javascript 코드를 조작하는 것이다. Client-Side에 민감한 데이터를 넣어놨다면 해당 공격을 통해 탈취가 가능해진다.

7. DDos 
서버에 비정상적인 트래픽을 보내 마비시키는 공격이다.

8. Dictionary Attack
하나만 걸려라 공격 -> 데이터베이스에 많은 문자열을 막 삽입해서 비밀번호를 알아내는 방법이다. 


# api 요청 옵션들을 설명해주세요.

- <code>Keep Alive</code>: 네트워크 연결에서 사용되는 설정 중 하나로, 연결을 활성 상태로 유지하거나 비활성화하는 데 사용, 동일한 연결을 재사용하여 다수의 요청을 처리할 수 있다. 이렇게 하면 연결을 설정하고 해제하는 데 필요한 오버헤드가 줄어들어 성능 향상이 이루어질 수 있다. -> 기본값 true
- <code>Timeout (타임아웃)</code>: 타임아웃 옵션은 서버로부터 응답을 받을 때까지 기다리는 최대 시간을 설정. 만약 서버가 지정된 시간 내에 응답하지 않으면 요청은 실패한다. 이것은 응답이 없거나 네트워크 문제로 인한 지연을 처리하는 데 유용

```javascript
import axios from 'axios';

// Axios 인스턴스를 생성한다.
const instance = axios.create({
  baseURL: 'https://api.example.com', // 요청을 보낼 서버의 기본 URL
  
  // timeout 옵션 설정 (5초)
  timeout: 5000, // 요청이 5초 동안 응답을 기다립니다.
});
```
- <code>HTTP Method (HTTP 메서드)</code>: HTTP 요청의 종류를 나타내는 메서드를 선택할 수 있다. 가장 일반적인 메서드로는 GET (데이터를 가져오기), POST (데이터를 서버로 보내기), PUT (데이터 업데이트), DELETE (데이터 삭제) 등이 있다.
- <code>Headers (헤더)</code>: 요청과 관련된 추가 정보를 헤더에 포함할 수 있음. 예를 들어, 인증 정보나 사용자 에이전트(user-agent) 정보를 헤더에 추가 가능
- <code>Query Parameters (쿼리 매개변수)</code>: URL에 추가 매개변수를 포함하여 서버에 추가 정보를 전달, 예를 들어, 검색어나 필터링 매개변수를 URL에 추가 가능
- <code>Request Body (요청 본문)</code>:  POST 또는 PUT 요청에서 데이터를 서버로 보낼 때 사용, 보통 json을 사용
- <code>Authentication (인증)</code>: 요청에 대한 인증 정보를 포함하여 보안된 엔드포인트에 접근 가능 -> 인증 토큰 등을 담음
- <code>Caching (캐싱)</code>: 요청 결과를 로컬 캐시에 저장하여 동일한 요청을 다시 보내지 않고 캐시된 데이터를 사용할 수 있게 함. -> 서버 부하를 줄임. -> 기본값은 true
```jsx
const axios = require('axios');

// Axios 인스턴스 생성
const instance = axios.create({
  baseURL: 'https://api.example.com', // 원격 API의 기본 URL
  timeout: 5000, // 요청 타임아웃(ms)
  headers: {
    'Cache-Control': 'no-cache', // 캐시 비활성화
  },
});

// GET 요청
instance.get('/data')
  .then((response) => {
    console.log('Response Data:', response.data);
  })
  .catch((error) => {
    console.error('Error:', error);
  });
```

# CSR과 SSR의 차이점을 알려주세요.
싱글 페이지 렌더링이란? SPA는 최초 한번 페이지 전체를 로딩한 후부터 데이터만 변경해서 사용할 수 있는 웹 애플리케이션이다. -> 하나의 페이지에서 실행된다.
종류로는 CSR과 SSR이 있다. 

### CSR 클라이언트 사이드 렌더링 
최초 로드시 필요한 파일들을 전부 받고, 사용자의 인터렉션에 따라 클라이언트단에서 받아와 렌더링을 해주는 방식 
기본 틀만 받고, 브라우저에서 동적으로 DOM을 그린다. 
단점으로는 
1. 초반에 뼈대만 다운받기 때문에, SEO에 취약하다. 또한 초기 화면의 렌더링 속도가 느리다. 하지만 이후의 렌더링 속도가 빠르게 일어난다. 
2. SEO에 취약하다. (브라우저가 서버에서 받아오는 최초의 HTML은 고작 <div id="root"></div> 태그 하나이기 때문에 검색엔진이 사이트의 내용을 파악하기 어렵다.)

### SSR 서버 사이드 렌더링
서버에서 새로운 페이지에 대한 요청을 하는 방식으로 서버로 부터 이미 만들어진 DOM을 받게 됩니다.
따라서 SEO에 최적화되어 있다.

단점으로는
1. 매 렌더링마다 서버를 거침으로써 속도가 CSR에 비해 느립니다.


# 여러 언어로 되어 있는 콘텐츠의 페이지를 어떻게 제공하나요?

- 여러 언어로 제공되는 페이지를 제공하기 위해선 페이지 내의 내용이 하나의 일관된 언어로 표시되어야 한다. 브라우저가 HTTP 요청을 서버에 보내면, 대게 Accept-Language와 같은 기본 언어에 대한 설정 정보를 보낸다. 서버는 이 정보를 확인하고 해당 언어에 맞는 문서를 반환한다. 이 때 태그의 lang 속성을 선언해줘야 한다.
- 서버는 일반적으로 백엔드 프레임워크의 도움을 받아, 특정 언어로 HTML 마크업에서 YML 또는 JSON 형식의 특정 언어에 대한 placeholder와 내용을 포함하여 HTML 페이지를 동적 생성한다.


# URI, URL, URN이란?

<img src="https://github.com/bumsly/tech-inverview-study/assets/65000254/418d4fda-e808-43c6-8212-360f92ae56ac"  width="400"/>

### URI

- URI(Uniform Resource Identifier) = 통합 자원 식별자
- 즉, 인터넷 상의 **“자원 자체”**를 식별하는 고유한 문자열 시퀀스이다.
- URI의 하위 개념으로 URL과 URN이 있다.
- URL도 아니고 URN도 아니면 그냥 URI가 되는 것이다.

### URL

- URL(Uniform Resource Locator) = 웹 사이트 주소 + 네트워크 상의 자원
- URL은 네트워크 상에서 리소스(웹 페이지, 이미지, 동영상 등의 파일)의 위치를 나타내기 위한 규약이다.
- URL은 HTTP 프로토콜 뿐만 아니라 FTP, SMTP 등 다른 프로토콜에서도 사용할 수 있다. (즉, 주소 뿐 아니라 프로토콜도 알아야 접속이 된다.)

### URN

- URN(Uniform Resource Name)
- URN은 URI의 표준 포맷 중 하나로, 이름으로 리소스를 특정하는 URI이다.
- http와 같은 프로토콜을 제외하고 리소스의 name을 가리키는데 사용된다.
- URN에는 리소스 접근방법과, 웹 상의 위치가 표기되지 않는다. (웹 문서의 물리적인 위치와 상관 없이 웹 문서 자체를 의미)
- 실제 자원을 찾기 위해서는 URN을 URL로 변환하여 이용한다.

<img src="https://github.com/bumsly/tech-inverview-study/assets/65000254/1882d766-dd7a-48a6-a6bf-3ee50385e52d"  width="500"/>


# CWV에 대해서 설명해주세요.
Core Web Virtal이다. 
Google에서 검색 순위 알고리즘의 일부로 사용하는 웹 성능 메트릭

### 종류 
1. <code>FCP (First Contentful Paint)</code>: 웹페이지에서 첫 번째 컨텐츠가 브라우저에 렌더링되기 시작한 시간을 나타낸다. 사용자가 페이지의 로딩이 시작되었다고 인식하는 지점이다.
2. <code>LCP (Largest Contentful Paint)</code>: 로딩 중에 가장 큰 요소(이미지, 비디오, 텍스트 블록 등)가 브라우저에 렌더링되기 시작한 시간을 나타낸다. 이 값이 작을수록 페이지 로딩이 빠르다고 볼 수 있다.
3. <code>FID (First Input Delay)</code>: 페이지가 로딩된 후 사용자가 처음으로 상호 작용할 수 있는 시점까지 걸리는 시간을 나타낸다. 이 값이 낮을수록 사용자는 페이지에 빠르게 반응할 수 있다.
4. <code>CLS (Cumulative Layout Shift)</code>: 페이지 로딩 중에 레이아웃이 얼마나 안정적인지를 나타낸다. 즉, 사용자가 예상치 않게 레이아웃이 바뀌는 정도를 측정한다.
5. <code>TTFB (Time to First Byte)</code>: 사용자가 페이지를 요청하고 첫 번째 바이트가 브라우저에 도착하는데까지 걸리는 시간을 나타낸다. 이 값은 서버 응답 시간을 측정한다.
6. <code>TBT (Total Blocking Time)</code>: 페이지 로딩 중에 브라우저가 사용자 입력에 응답하지 않는 총 시간을 나타낸다. 사용자 입력을 처리하는데 얼마나 시간이 걸렸는지를 나타내는 중요한 지표이다.
7. <code>FP(First Paint)</code>: 첫번째 픽셀이 스크린에 페인팅 되었을 때 (시간)을 말한다. 예를 들어 background-color가 적용되는 순간을 의미한다. 

이러한 지표들은 모두 웹 페이지의 성능을 평가하고 사용자 경험을 향상시키기 위해 개발자들에게 중요한 정보를 제공한다.
