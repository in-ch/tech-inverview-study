# MVC, MVVM 모델에 대해 설명해주세요.
소프트웨어 디자인 패턴, 어플리케이션을 세 개의 영역으로 분할하고 각 구성 요소에게 고유한 역할을 부여하는 개발 방식.

MVC 패턴 (모델, 뷰, 컨트롤러) - 모델은 데이터 및 데이터를 처리하는 부분이고, view는 사용자에게 보여지는 UI 부분이다. 컨트롤러는 사용자의 입력을 받고 처리하는 부분이다. MVC는 사용자의 액션이 컨트롤러에 들어오면, 컨트롤러가 액션을 확인하고 모델을 업데이트한다. 컨트롤러는 모델을 나타내줄 view를 선택하고, view는 모델을 이용하여 화면을 나타낸다. 컨트롤러는 여러 개의 view를 선택할 수 있는 1:n 구조이고, 뷰를 선택할 뿐 직접 업데이트는 하지 않는다.
보편적으로 널리 사용되는 패턴이며, 단점은 뷰와 모델 사이의 의존성이 높고, 어플리케이션이 커질수록 복잡하고, 유지 보수가 어렵다는 점이다.
위의 개념을 WEB에 적용하면,
1. **사용자가 웹사이트에 접속 (Users)**
2. **Controller는 사용자가 요청한 웹페이지를 서비스하기 위해서 모델을 호출 (Manipulates)**
3. **Model은 데이터베이스나 파일과 같은 데이터 소스를 제어한 후 그 결과를 Return**
4. **Controller는 Model이 리턴한 결과를 View에 반영 (Updates)**
5. **데이터가 반영된 View는 사용자에게 보여짐 (Sees)**

MVVM 패턴 (모델, 뷰, 뷰모델) - 모델과 뷰는 MVC와 동일하다. 뷰모델은 뷰를 표현하기 위해 만든 모델이다. 또 뷰를 나타내기 위해 데이터 처리를 하는 부분이다. 액션이 뷰를 통해 들어오면, 뷰 모델에 액션을 전달한다. 뷰 모델은 모델에게 데이터를 요청하고, 모델은 요청 받은 데이터를 뷰 모델에게 응답하고, 뷰 모델은 받은 데이터를 가공하여 저장한다. 뷰는 뷰 모델과 데이터 바인딩을 하여 화면을 그리는 동작 방식이다.
이 패턴의 가장 큰 장점은 뷰와 뷰 모델의 의존성을 없애고, 각 부분이 독립적이라는 것이다. 단점은 뷰 모델의 설계가 쉽지 않다는 점이다. 이 패턴의 주요 목적은 로직의 분리이다. 리액트에서는 데이터와 화면 컴포넌트를 분리하는 것을 예시로 들 수 있다.

# HTTP와 HTTPS의 차이점은?
HTTP는 서버/클라이언트 모델을 따라 데이터를 주고받기 위한 프로토콜이다. HTTPS는 HTTP에 데이터 암호화가 추가된 프로토콜이다. 공개키/개인키 암호화 방식을 이용해 데이터를 암호화한다. HTTP는 암호화가 추가되지 않았기 때문에 보안에 취약한 반면, HTTPS는 안전하게 데이터를 주고받을 수 있다. 하지만 HTTPS를 이용하면 암호화/복호화 과정이 필요하기 때문에 HTTP보다 속도가 느리다(그러나 실 사용에서는 크게 차이는 없다.) HTTPS는 인증서를 발급하고 유지하는데에 추가 비용이 발생한다. 개인정보와 같은 민감한 데이터를 주고 받는다면 HTTPS를 이용해야 하지만, 단순 정보 조회 같은 사이트는 HTTP를 적용하면 된다.

HTTP 포트 번호 : 80
HTTPS 포트 번호: 443


# CORS 에러 - 정의, 특징, 해결 방법

웹 브라우저에서 발생하는 보안 관련 오류 중 하나로, 다른 출처(origin)로부터 리소스를 로드하려는 시도가 실패할 때 발생한다.

웹 브라우저는 보안 상의 이유로 동일 출처 정책(Same-Origin Policy)을 따르는데, 이는 웹 페이지가 한 출처에서 로드된 리소스만 접근할 수 있다는 원칙이다. 

출처란 웹 페이지의 도메인, 포트, 프로토콜을 의미하며, 다른 출처에 있는 리소스에 접근하려면 해당 출처에서 CORS를 허용한다.

- 특징 

1. 오류 메시지: 보통 웹 브라우저의 개발자 도구 콘솔에서 확인할 수 있으며, 오류 메시지에는 <code>Access to XMLHttpRequest at 'URL' from origin 'origin' has been blocked by CORS policy</code>와 같이 출처 관련 정보가 포함한다.

2. Same-Origin Policy: 기본적으로 브라우저는 동일 출처 정책을 적용하며, 다른 출처에서 리소스에 접근하려면 해당 출처에서 CORS를 허용한다.

3. 보안: CORS는 웹 보안을 강화하기 위한 기술로, 잘못된 설정 또는 공격을 방지하기 위해 도입된다.

- CORS 에러 해결 방법:

1. 서버 설정: 서버 측에서 CORS를 허용하도록 설정해야 합니다. 이를 위해서는 서버 응답 헤더에 CORS 관련 헤더를 추가해야 합니다. 주요 헤더는 다음과 같습니다.

<code>Access-Control-Allow-Origin</code>: 허용할 출처를 지정합니다. <code>*</code>는 모든 출처를 허용하는 것을 의미
<code>Access-Control-Allow-Methods</code>: 허용할 HTTP 메서드를 지정
<code>Access-Control-Allow-Headers</code>: 허용할 요청 헤더를 지정합니다.
<code>Access-Control-Allow-Credentials</code>: 자격 증명 허용 여부를 지정한다.(예: 쿠키 전송 허용 여부).

2. 프록시 서버 사용: 클라이언트와 서버 사이에 프록시 서버를 두어 CORS 에러를 우회할 수 있다. 클라이언트는 프록시 서버에 요청을 보내고, 프록시 서버는 해당 요청을 서버로 전달하고 서버 응답을 클라이언트에게 전달한다. 이를 통해 서버와 클라이언트 간의 출처가 동일한 것처럼 동작할 수 있다.

3. JSONP 사용: <code>JSONP(JSON with Padding)</code>는 CORS 에러를 피하기 위한 대체 방법 중 하나로, 서버에서 <code>JSONP</code>를 지원하는 경우에 사용할 수 있다. 그러나 보안상의 이유로 사용을 권장하지 않는다.

# cors가 왜 등장했는지에 대해 설명해주세요.

보안 상의 이유로 등장했다. 출처가 다른 두 개의 어플리케이션이 마음대로 소통할 수 있는 환경은 꽤 위험한 환경이다. 웹에서 돌아가는 클라이언트 어플리케이션은 사용자의 공격에 너무나도 취약하기 떄문에 이런 상황 속에서 다른 출처의 어플리케이션이 서로 통신하는 것에 대해 아무런 제약도 존재하지 않는다면, 악의를 가진 사용자가 소스 코드를 쓱 구경한 후 <code>CSRF(Cross-Site Request Forgery)</code>나 XSS(Cross-Site Scripting)와 같은 방법을 사용한다면 어플리케이션에서 코드가 실행된 것처럼 꾸며서 사용자의 정보를 탈취하기가 너무나도 쉬워진다. 

여기서 <code>CSRF</code>란 웹 보안 공격 중 하나로, 공격자가 사용자의 웹 브라우저를 통해 사용자의 의지와 동의 없이 특정 웹 애플리케이션에 요청을 보내는 공격
<code>XSS(Cross Site Scripting)</code>는 공격자가 웹 페이지에 악성 스크립트 코드를 삽입하여 해당 스크립트 코드를 실행하도록 만드는 공격

# 쿠키, 세션, 로컬 스토리지의 장단점 
| LocalStorage | SessionStorage | Cookie |
| --- | --- | --- |
| 저장한 데이터를 지우지 않는 이상 영구적 보관이 가능 | 세선 종료 시 클라이언트에 대한 정보 삭제 | 모든 요청에 쿠키 정보가 포함되므로 서버 부담이 증가 |
| 5mb | 5mb | 4kb  |
| 다른 탭에서 값 공유 가능 | 탭마다의 고유한 값이므로 다른 탭에서 공유 안됨 | 도메인에 바인딩되므로 탭 간에 공유가 된다.  |
| HTTP 요청에서 데이터를 주고받지 않고 LocalStorage를 이용하면 클라이언트와 서버간의 전체 트래픽과 낭비되는 대역폭의 양을 줄일 수 있음 |  |  |

# RESTful API에 대해서 설명해주세요. 
RESTful API는 HTTP 프로토콜을 기반으로 하는 웹 서비스 아키텍처입니다. 자원, 메소드, 메시지 등을 정의하여 클라이언트-서버 간의 통신을 가능하게 합니다. 또한, RESTful API는 표준 HTTP 메소드(GET, POST, PUT, DELETE)를 사용하여 서버와 통신합니다. 

## 여기서 HTTP 메서드란 
- GET: 서버에서 리소스(데이터)를 요청하는 메소드, 요청한 데이터를 가져와 응답
- POST: 서버에 데이터를 전송하는 메소드, 데이터를 전송하여 서버에서 처리하고, 처리 결과를 응답
- PUT: 서버에 데이터를 업데이트하는 메소드, 요청한 데이터를 서버에 저장하고, 처리 결과를 응답
- DELETE: 서버에서 데이터를 삭제하는 메소드, 요청한 데이터를 삭제하고, 처리 결과를 응답

# 비동기 함수에 대해서 설명해주세요.
비동기 함수(Asynchronous function)는 함수의 실행 결과가 즉시 반환되지 않고, 특정 조건이 충족될 때까지 기다리는 함수다. 비동기 함수는 일반적으로 콜백 함수나 Promise 객체를 반환한다.
콜백 함수는 비동기 작업이 완료되었을 때 호출되는 함수이며,
Promise 객체는 비동기 작업이 성공적으로 완료되었는지 혹은 실패했는지 나타내는 객체다.

비동기 함수는 애플리케이션의 성능을 향상시키고, 사용자 인터페이스의 반응성을 유지하는 데 유용하다. 그러나 비동기 함수를 사용할 때는 콜백 지옥과 같은 문제를 피하기 위해 적절한 에러 처리와 코드 구성이 필요하다. 여러 개의 비동기 함수가 실행되면, 이벤트 루프는 비동기 함수 호출을 처리하고, 비동기 함수가 완료되었을 때 콜백 함수를 호출한다. 이벤트 루프는 실행 대기 중인 비동기 함수가 있으면 해당 함수를 호출하고, 실행이 완료될 때까지 다음 비동기 함수를 호출한다. 따라서, 여러 개의 비동기 함수가 실행될 때 이들 함수는 동시에 실행되며, 이벤트 루프에 의해 비동기 함수의 실행 순서가 제어된다.

### 그렇다면 비동기 함수는 왜 사용할까요?
- 응답 시간 개선: 비동기 함수를 사용하면 여러 작업을 동시에 처리할 수 있으므로 시스템 응답 시간을 개선할 수 있습니다. 특히 네트워크 호출, 파일 I/O 등의 작업에서 높은 효율을 얻을 수 있습니다.

- 블로킹 방지: 동기 함수는 한 작업이 끝나야 다음 작업을 진행할 수 있지만, 비동기 함수는 여러 작업을 동시에 처리하므로 다른 작업을 블로킹하지 않습니다. 이것은 대화 시스템에서 여러 요청을 동시에 처리하려는 경우에 유용합니다.

- 자원 활용 최적화: 비동기 함수를 사용하면 CPU 및 기타 자원을 더 효율적으로 활용할 수 있습니다. 대기 시간이 긴 작업을 수행하는 동안 다른 작업을 수행할 수 있으므로 시스템의 성능이 향상됩니다.

# 브라우저의 렌더링 원리를 설명해주세요.

브라우저 렌더링은 HTML, CSS, Javascript 등의 웹 페이지 자원을 브라우저가 화면에 그리는 과정을 말합니다. 브라우저 렌더링 원리와 순서는 크게 다음과 같은 단계로 구성됩니다.

1. 불러오기 (Loading)
    HTTP 모듈 또는 파일 시스템으로 전달 받은 리소스 스트림을 읽는 과정으로 로더가 이 역할을 맡고 있다. 로더는 단순히 읽는 것이 아니라, 이미 데이터를 읽었는지도 확인하고, 팝업창을 열지 말지, 또는 파일 다운로드 받을지를 결정한다.
    
2. 다운받은 HTML, CSS를 Object Model로 만든다.
    - HTML → DOM
        HTML파일은 HTML파서에 의해 파싱되어 DOM트리로 변환된다.
    - CSS → CSSOM (<link>, <style>을 통하여 생성)
        CSS파일은 CSS파서에 의해 파싱되어 CSSOM트리로 변환된다.
        
3. DOM과 CSSOM을 합쳐 Render tree를 만든다.
   
5. Layout
    렌더트리를 토대로 그려질 노드와 그 스타일값과 치수까지 계산한다.
    
6. Paint
    이 정보들을 페인팅 단계로 전달해서 렌더트리의 각 노드를 화면 상의 실제 픽셀로 변환한다.

다시 정리하자면 

1. DOM을 생성합니다. 브라우저는 HTML 문서를 파싱하여 DOM 트리를 생성합니다. 이때 HTML 태그를 노드로 변환하고, 노드 간의 계층 관계를 형성합니다.
2. 브라우저는 CSS 파일을 파싱하여 CSSOM을 생성합니다. 이때, CSS 속성을 노드로 변환하고, 노드간의 계층 관계를 형성합니다.
3. DOM 트리와 CSSOM을 결합하여 렌더 트리를 생성합니다. 이때 실제 화면에 표시될 요소만을 선택하여 렌더 트리를 형성합니다. 
4. 이제, 브라우저는 렌더 트리를 이용하여 각 요소의 크기와 위치를 계산하는 과정인 레이아웃을 거쳐 화면에 요소를 그리는 페인팅 과정을 거치게 됩니다. 이때, 요소의 배경, 테두리, 글자 등을 그리게 됩니다. 


