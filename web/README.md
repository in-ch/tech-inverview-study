# MVC, MVVM 모델에 대해 설명해주세요.
소프트웨어 디자인 패턴, 어플리케이션을 세 개의 영역으로 분할하고 각 구성 요소에게 고유한 역할을 부여하는 개발 방식.

MVC 패턴 (모델, 뷰, 컨트롤러) - 모델은 데이터 및 데이터를 처리하는 부분이고, view는 사용자에게 보여지는 UI 부분이다. 컨트롤러는 사용자의 입력을 받고 처리하는 부분이다. MVC는 사용자의 액션이 컨트롤러에 들어오면, 컨트롤러가 액션을 확인하고 모델을 업데이트한다. 컨트롤러는 모델을 나타내줄 view를 선택하고, view는 모델을 이용하여 화면을 나타낸다. 컨트롤러는 여러 개의 view를 선택할 수 있는 1:n 구조이고, 뷰를 선택할 뿐 직접 업데이트는 하지 않는다.
보편적으로 널리 사용되는 패턴이며, 단점은 뷰와 모델 사이의 의존성이 높고, 어플리케이션이 커질수록 복잡하고, 유지 보수가 어렵다는 점이다.
위의 개념을 WEB에 적용하면,
1. **사용자가 웹사이트에 접속 (Users)**
2. **Controller는 사용자가 요청한 웹페이지를 서비스하기 위해서 모델을 호출 (Manipulates)**
3. **Model은 데이터베이스나 파일과 같은 데이터 소스를 제어한 후 그 결과를 Return**
4. **Controller는 Model이 리턴한 결과를 View에 반영 (Updates)**
5. **데이터가 반영된 View는 사용자에게 보여짐 (Sees)**

MVVM 패턴 (모델, 뷰, 뷰모델) - 모델과 뷰는 MVC와 동일하다. 뷰모델은 뷰를 표현하기 위해 만든 모델이다. 또 뷰를 나타내기 위해 데이터 처리를 하는 부분이다. 액션이 뷰를 통해 들어오면, 뷰 모델에 액션을 전달한다. 뷰 모델은 모델에게 데이터를 요청하고, 모델은 요청 받은 데이터를 뷰 모델에게 응답하고, 뷰 모델은 받은 데이터를 가공하여 저장한다. 뷰는 뷰 모델과 데이터 바인딩을 하여 화면을 그리는 동작 방식이다.
이 패턴의 가장 큰 장점은 뷰와 뷰 모델의 의존성을 없애고, 각 부분이 독립적이라는 것이다. 단점은 뷰 모델의 설계가 쉽지 않다는 점이다. 이 패턴의 주요 목적은 로직의 분리이다. 리액트에서는 데이터와 화면 컴포넌트를 분리하는 것을 예시로 들 수 있다.

# HTTP와 HTTPS의 차이점은?
HTTP는 서버/클라이언트 모델을 따라 데이터를 주고받기 위한 프로토콜이다. HTTPS는 HTTP에 데이터 암호화가 추가된 프로토콜이다. 공개키/개인키 암호화 방식을 이용해 데이터를 암호화한다. HTTP는 암호화가 추가되지 않았기 때문에 보안에 취약한 반면, HTTPS는 안전하게 데이터를 주고받을 수 있다. 하지만 HTTPS를 이용하면 암호화/복호화 과정이 필요하기 때문에 HTTP보다 속도가 느리다(그러나 실 사용에서는 크게 차이는 없다.) HTTPS는 인증서를 발급하고 유지하는데에 추가 비용이 발생한다. 개인정보와 같은 민감한 데이터를 주고 받는다면 HTTPS를 이용해야 하지만, 단순 정보 조회 같은 사이트는 HTTP를 적용하면 된다.

HTTP 포트 번호 : 80
HTTPS 포트 번호: 443


# CORS 에러 - 정의, 특징, 해결 방법

웹 브라우저에서 발생하는 보안 관련 오류 중 하나로, 다른 출처(origin)로부터 리소스를 로드하려는 시도가 실패할 때 발생한다.

웹 브라우저는 보안 상의 이유로 동일 출처 정책(Same-Origin Policy)을 따르는데, 이는 웹 페이지가 한 출처에서 로드된 리소스만 접근할 수 있다는 원칙이다. 

출처란 웹 페이지의 도메인, 포트, 프로토콜을 의미하며, 다른 출처에 있는 리소스에 접근하려면 해당 출처에서 CORS를 허용한다.

- 특징 

1. 오류 메시지: 보통 웹 브라우저의 개발자 도구 콘솔에서 확인할 수 있으며, 오류 메시지에는 <code>Access to XMLHttpRequest at 'URL' from origin 'origin' has been blocked by CORS policy</code>와 같이 출처 관련 정보가 포함한다.

2. Same-Origin Policy: 기본적으로 브라우저는 동일 출처 정책을 적용하며, 다른 출처에서 리소스에 접근하려면 해당 출처에서 CORS를 허용한다.

3. 보안: CORS는 웹 보안을 강화하기 위한 기술로, 잘못된 설정 또는 공격을 방지하기 위해 도입된다.

- CORS 에러 해결 방법:

1. 서버 설정: 서버 측에서 CORS를 허용하도록 설정해야 합니다. 이를 위해서는 서버 응답 헤더에 CORS 관련 헤더를 추가해야 합니다. 주요 헤더는 다음과 같습니다.

<code>Access-Control-Allow-Origin</code>: 허용할 출처를 지정합니다. <code>*</code>는 모든 출처를 허용하는 것을 의미
<code>Access-Control-Allow-Methods</code>: 허용할 HTTP 메서드를 지정
<code>Access-Control-Allow-Headers</code>: 허용할 요청 헤더를 지정합니다.
<code>Access-Control-Allow-Credentials</code>: 자격 증명 허용 여부를 지정한다.(예: 쿠키 전송 허용 여부).

2. 프록시 서버 사용: 클라이언트와 서버 사이에 프록시 서버를 두어 CORS 에러를 우회할 수 있다. 클라이언트는 프록시 서버에 요청을 보내고, 프록시 서버는 해당 요청을 서버로 전달하고 서버 응답을 클라이언트에게 전달한다. 이를 통해 서버와 클라이언트 간의 출처가 동일한 것처럼 동작할 수 있다.

3. JSONP 사용: <code>JSONP(JSON with Padding)</code>는 CORS 에러를 피하기 위한 대체 방법 중 하나로, 서버에서 <code>JSONP</code>를 지원하는 경우에 사용할 수 있다. 그러나 보안상의 이유로 사용을 권장하지 않는다.

# cors가 왜 등장했는지에 대해 설명해주세요.

보안 상의 이유로 등장했다. 출처가 다른 두 개의 어플리케이션이 마음대로 소통할 수 있는 환경은 꽤 위험한 환경이다. 웹에서 돌아가는 클라이언트 어플리케이션은 사용자의 공격에 너무나도 취약하기 떄문에 이런 상황 속에서 다른 출처의 어플리케이션이 서로 통신하는 것에 대해 아무런 제약도 존재하지 않는다면, 악의를 가진 사용자가 소스 코드를 쓱 구경한 후 <code>CSRF(Cross-Site Request Forgery)</code>나 XSS(Cross-Site Scripting)와 같은 방법을 사용한다면 어플리케이션에서 코드가 실행된 것처럼 꾸며서 사용자의 정보를 탈취하기가 너무나도 쉬워진다. 

여기서 <code>CSRF</code>란 웹 보안 공격 중 하나로, 공격자가 사용자의 웹 브라우저를 통해 사용자의 의지와 동의 없이 특정 웹 애플리케이션에 요청을 보내는 공격
<code>XSS(Cross Site Scripting)</code>는 공격자가 웹 페이지에 악성 스크립트 코드를 삽입하여 해당 스크립트 코드를 실행하도록 만드는 공격

# 쿠키, 세션, 로컬 스토리지의 장단점 
| LocalStorage | SessionStorage | Cookie |
| --- | --- | --- |
| 저장한 데이터를 지우지 않는 이상 영구적 보관이 가능 | 세선 종료 시 클라이언트에 대한 정보 삭제 | 모든 요청에 쿠키 정보가 포함되므로 서버 부담이 증가 |
| 5mb | 5mb | 4kb  |
| 다른 탭에서 값 공유 가능 | 탭마다의 고유한 값이므로 다른 탭에서 공유 안됨 | 도메인에 바인딩되므로 탭 간에 공유가 된다.  |
| HTTP 요청에서 데이터를 주고받지 않고 LocalStorage를 이용하면 클라이언트와 서버간의 전체 트래픽과 낭비되는 대역폭의 양을 줄일 수 있음 |  |  |

# RESTful API에 대해서 설명해주세요. 
RESTful API는 HTTP 프로토콜을 기반으로 하는 웹 서비스 아키텍처입니다. 자원, 메소드, 메시지 등을 정의하여 클라이언트-서버 간의 통신을 가능하게 합니다. 또한, RESTful API는 표준 HTTP 메소드(GET, POST, PUT, DELETE)를 사용하여 서버와 통신합니다. 

## 여기서 HTTP 메서드란 
- GET: 서버에서 리소스(데이터)를 요청하는 메소드, 요청한 데이터를 가져와 응답
- POST: 서버에 데이터를 전송하는 메소드, 데이터를 전송하여 서버에서 처리하고, 처리 결과를 응답
- PUT: 서버에 데이터를 업데이트하는 메소드, 요청한 데이터를 서버에 저장하고, 처리 결과를 응답
- DELETE: 서버에서 데이터를 삭제하는 메소드, 요청한 데이터를 삭제하고, 처리 결과를 응답

# 비동기 함수에 대해서 설명해주세요.
비동기 함수(Asynchronous function)는 함수의 실행 결과가 즉시 반환되지 않고, 특정 조건이 충족될 때까지 기다리는 함수다. 비동기 함수는 일반적으로 콜백 함수나 Promise 객체를 반환한다.
콜백 함수는 비동기 작업이 완료되었을 때 호출되는 함수이며,
Promise 객체는 비동기 작업이 성공적으로 완료되었는지 혹은 실패했는지 나타내는 객체다.

비동기 함수는 애플리케이션의 성능을 향상시키고, 사용자 인터페이스의 반응성을 유지하는 데 유용하다. 그러나 비동기 함수를 사용할 때는 콜백 지옥과 같은 문제를 피하기 위해 적절한 에러 처리와 코드 구성이 필요하다. 여러 개의 비동기 함수가 실행되면, 이벤트 루프는 비동기 함수 호출을 처리하고, 비동기 함수가 완료되었을 때 콜백 함수를 호출한다. 이벤트 루프는 실행 대기 중인 비동기 함수가 있으면 해당 함수를 호출하고, 실행이 완료될 때까지 다음 비동기 함수를 호출한다. 따라서, 여러 개의 비동기 함수가 실행될 때 이들 함수는 동시에 실행되며, 이벤트 루프에 의해 비동기 함수의 실행 순서가 제어된다.

### 그렇다면 비동기 함수는 왜 사용할까요?
- 응답 시간 개선: 비동기 함수를 사용하면 여러 작업을 동시에 처리할 수 있으므로 시스템 응답 시간을 개선할 수 있습니다. 특히 네트워크 호출, 파일 I/O 등의 작업에서 높은 효율을 얻을 수 있습니다.

- 블로킹 방지: 동기 함수는 한 작업이 끝나야 다음 작업을 진행할 수 있지만, 비동기 함수는 여러 작업을 동시에 처리하므로 다른 작업을 블로킹하지 않습니다. 이것은 대화 시스템에서 여러 요청을 동시에 처리하려는 경우에 유용합니다.

- 자원 활용 최적화: 비동기 함수를 사용하면 CPU 및 기타 자원을 더 효율적으로 활용할 수 있습니다. 대기 시간이 긴 작업을 수행하는 동안 다른 작업을 수행할 수 있으므로 시스템의 성능이 향상됩니다.

# 브라우저의 렌더링 원리를 설명해주세요.

브라우저 렌더링은 HTML, CSS, Javascript 등의 웹 페이지 자원을 브라우저가 화면에 그리는 과정을 말합니다. 브라우저 렌더링 원리와 순서는 크게 다음과 같은 단계로 구성됩니다.

1. 불러오기 (Loading)
    HTTP 모듈 또는 파일 시스템으로 전달 받은 리소스 스트림을 읽는 과정으로 로더가 이 역할을 맡고 있다. 로더는 단순히 읽는 것이 아니라, 이미 데이터를 읽었는지도 확인하고, 팝업창을 열지 말지, 또는 파일 다운로드 받을지를 결정한다.
    
2. 다운받은 HTML, CSS를 Object Model로 만든다.
    - HTML → DOM
        HTML파일은 HTML파서에 의해 파싱되어 DOM트리로 변환된다.
    - CSS → CSSOM (<link>, <style>을 통하여 생성)
        CSS파일은 CSS파서에 의해 파싱되어 CSSOM트리로 변환된다.
        
3. DOM과 CSSOM을 합쳐 Render tree를 만든다.
   
5. Layout
    렌더트리를 토대로 그려질 노드와 그 스타일값과 치수까지 계산한다.
    
6. Paint
    이 정보들을 페인팅 단계로 전달해서 렌더트리의 각 노드를 화면 상의 실제 픽셀로 변환한다.

다시 정리하자면 

1. DOM을 생성합니다. 브라우저는 HTML 문서를 파싱하여 DOM 트리를 생성합니다. 이때 HTML 태그를 노드로 변환하고, 노드 간의 계층 관계를 형성합니다.
2. 브라우저는 CSS 파일을 파싱하여 CSSOM을 생성합니다. 이때, CSS 속성을 노드로 변환하고, 노드간의 계층 관계를 형성합니다.
3. DOM 트리와 CSSOM을 결합하여 렌더 트리를 생성합니다. 이때 실제 화면에 표시될 요소만을 선택하여 렌더 트리를 형성합니다. 
4. 이제, 브라우저는 렌더 트리를 이용하여 각 요소의 크기와 위치를 계산하는 과정인 레이아웃을 거쳐 화면에 요소를 그리는 페인팅 과정을 거치게 됩니다. 이때, 요소의 배경, 테두리, 글자 등을 그리게 됩니다. 


# api 요청 옵션들을 설명해주세요.

- <code>Keep Alive</code>: 네트워크 연결에서 사용되는 설정 중 하나로, 연결을 활성 상태로 유지하거나 비활성화하는 데 사용, 동일한 연결을 재사용하여 다수의 요청을 처리할 수 있습니다. 이렇게 하면 연결을 설정하고 해제하는 데 필요한 오버헤드가 줄어들어 성능 향상이 이루어질 수 있다. -> 기본값 true
- <code>Timeout (타임아웃)</code>: 타임아웃 옵션은 서버로부터 응답을 받을 때까지 기다리는 최대 시간을 설정. 만약 서버가 지정된 시간 내에 응답하지 않으면 요청은 실패합니다. 이것은 응답이 없거나 네트워크 문제로 인한 지연을 처리하는 데 유용

```javascript
import axios from 'axios';

// Axios 인스턴스를 생성합니다.
const instance = axios.create({
  baseURL: 'https://api.example.com', // 요청을 보낼 서버의 기본 URL
  
  // timeout 옵션 설정 (5초)
  timeout: 5000, // 요청이 5초 동안 응답을 기다립니다.
});
```
- <code>HTTP Method (HTTP 메서드)</code>: HTTP 요청의 종류를 나타내는 메서드를 선택할 수 있다. 가장 일반적인 메서드로는 GET (데이터를 가져오기), POST (데이터를 서버로 보내기), PUT (데이터 업데이트), DELETE (데이터 삭제) 등이 있다.
- <code>Headers (헤더)</code>: 요청과 관련된 추가 정보를 헤더에 포함할 수 있음. 예를 들어, 인증 정보나 사용자 에이전트(user-agent) 정보를 헤더에 추가 가능
- <code>Query Parameters (쿼리 매개변수)</code>: URL에 추가 매개변수를 포함하여 서버에 추가 정보를 전달, 예를 들어, 검색어나 필터링 매개변수를 URL에 추가 가능
- <code>Request Body (요청 본문)</code>:  POST 또는 PUT 요청에서 데이터를 서버로 보낼 때 사용, 보통 json을 사용
- <code>Authentication (인증)</code>: 요청에 대한 인증 정보를 포함하여 보안된 엔드포인트에 접근 가능 -> 인증 토큰 등을 담음
- <code>Caching (캐싱)</code>: 요청 결과를 로컬 캐시에 저장하여 동일한 요청을 다시 보내지 않고 캐시된 데이터를 사용할 수 있게 함. -> 서버 부하를 줄임. -> 기본값은 true
```jsx
const axios = require('axios');

// Axios 인스턴스 생성
const instance = axios.create({
  baseURL: 'https://api.example.com', // 원격 API의 기본 URL
  timeout: 5000, // 요청 타임아웃(ms)
  headers: {
    'Cache-Control': 'no-cache', // 캐시 비활성화
  },
});

// GET 요청
instance.get('/data')
  .then((response) => {
    console.log('Response Data:', response.data);
  })
  .catch((error) => {
    console.error('Error:', error);
  });
```

# Reflow와 Repaint에 대해 설명해주세요.

브라우저에서 Render Tree는 문서의 시각적 측면에서 올바른 순서대로 내용을 그리도록 하기 위한 목적을 갖고 있다. 따라서 DOM과 Render Tree는 항상 일치하지는 않는다. 예를 들어, display: none이나 head 같은 건 트리에서 제외시킨다. 그리고 브라우저는 layout 산출 후 painting 처리를 한다.
여기서 layout 계산을 다시 하는 것을 reflow, painting을 다시하는 것을 repainting이라고 하고 이것은 대개 필연적이다. 이것은 리소스를 소모하고 성능 저하를 유발할 수 있기 때문에 원인을 알고 최소화하는 것이 중요하다.

# 크로스 브라우징이란?

최대한 많은 종류의 웹 브라우저에서 정상적으로 작동하는 웹페이지를 만드는 방법론 중 하나다. 지금처럼 브라우저 하나가 시장을 독점하지 않고 다양한 브라우저가 시장을 나눠가지고 있을때 개발자는 그 다양한 브라우저에 호환되는 웹페이지를 개발해야한다. 따라서 W3C에 채택된 웹표준 기술을 기본으로 제작해야한다.
동일하게 보이는 것이 아니라, 동등한 수준의 정보, 기능 제공이 우선이기 때문에 제작자가 의도한 내용을 이상 없이 동작하게 하는 게 크로스 브라우징의 의미입니다.

# 웹 개발 시 고려해야 할 보안 공격에 대해서 설명해주세요.

1. SQL injection
서버에서 실행되는 SQL을 악위적으로 이용하는 공격, SQL 구문을 삽입하여 데이터 탈취, 삭제 등을 할 수 있다.

2. Cross-Site Scription (XSS)
웹 페이지에 악성 자바스크립트를 삽입하는 공격
보통 Cookie 혹은 LocalStorage을 탈취한다. -> 불특정 다수의 사용자 토큰을 손쉽게 탈취 

3. CSRF Attack(Cross-Site Request Forgery)
공격자가 서비스 사용자를 이용하여 요청을 보내는 공격 
예를 들어 네이버 로그인과 똑같은 화면을 제공하는 피싱 사이트를 이용하여 아이디와 비밀번호를 탈취하는 것이다. 
만약 CSRF에 대한 방어가 제대로 안되어 있다면 성공/실패 Response가 내려올 것이고 이를 통해 해커는 성공한 계정 정보를 판단하여 탈취할 수 있게 된다.

4. File Upload Attack
공격 스크립트가 담긴 파일을 서버로 업로드하는 공격이다.

5. Command Injection
쉘을 실행시키는 로직을 이용한 공격으로 시스템 권한이 탈취되는 것과 마찬가지로 치명적이다.
각 언어마다 쉘 명령을 실행할 수 있는 API가 존재하는데 이러한 API를 해커가 호출할 수 있게 방어가 안되어 있다면 치명적인 결과를 불러올 수 있다.

6. Javascript Injection
브라우저 console을 통해 Javascript 코드를 조작하는 것이다. Client-Side에 민감한 데이터를 넣어놨다면 해당 공격을 통해 탈취가 가능해진다.

7. DDos 
서버에 비정상적인 트래픽을 보내 마비시키는 공격이다.

8. Dictionary Attack
하나만 걸려라 공격 -> 데이터베이스에 많은 문자열을 막 삽입해서 비밀번호를 알아내는 방법이다.

# DNS란?

도메인 이름을 사용했을 때 입력한 도메인을 실제 네트워크 상에서 사용하는 IP 주소로 바꾸고 해당 IP 주소로 접속하는 과정이 필요하다. 이러한 과정, 전체 시스템을 DNS(도메인 네임 시스템)라고 한다.
- DNS는 전세계적으로 약속된 규칙을 공유한다.
- 상위 기관에서 인증된 기관에게 도메인을 생성하거나 IP 주소로 변경할 수 있는 ‘권한’을 부여한다.
- DNS는 이처럼 상위 기관과 하위 기관과 같은 **‘계층 구조’**를 가지는 **분산 데이터베이스 구조**를 가진다.
